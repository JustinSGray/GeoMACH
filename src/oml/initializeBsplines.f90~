
subroutine computeGroups(nsurf, nedge, surf_edge, ngroup, edge_group)

  implicit none

  !Fortran-python interface directives
  !f2py intent(in) nsurf, nedge, surf_edge
  !f2py intent(out) ngroup, edge_group
  !f2py depend(nsurf) surf_edge
  !f2py depend(nedge) edge_group

  !Input
  integer, intent(in) ::  nsurf, nedge
  integer, intent(in) ::  surf_edge(nsurf,2,2)

  !Output
  integer, intent(out) ::  ngroup
  integer, intent(out) ::  edge_group(nedge)

  !Working
  integer edge_group0(nedge)
  integer leftGroup, rightGroup, bottomGroup, topGroup
  integer i,j
  logical found

  do i=1,nedge
     edge_group0(i) = i
  end do

  do i=1,nsurf
     leftGroup = edge_group0(abs(surf_edge(i,2,1)))
     rightGroup = edge_group0(abs(surf_edge(i,2,2)))
     bottomGroup = edge_group0(abs(surf_edge(i,1,1)))
     topGroup = edge_group0(abs(surf_edge(i,1,2)))
     if (leftGroup .ne. rightGroup) then
        call setAll(nedge, leftGroup, rightGroup, edge_group0)
     end if
     if (bottomGroup .ne. topGroup) then
        call setAll(nedge, bottomGroup, topGroup, edge_group0)
     end if
  end do

  edge_group(:) = 0
  ngroup = 0
  do i=1,nedge
     found = .False.
     do j=1,nedge
        if (edge_group0(j) .eq. i) then
           if (.not. found) then
              ngroup = ngroup + 1
              found = .True.
           end if
           edge_group(j) = ngroup
        end if
     end do
  end do

end subroutine computeGroups



subroutine setAll(nedge, oldGroup, newGroup, edge_group0)

  implicit none

  !Input
  integer, intent(in) ::  nedge, oldGroup, newGroup

  !Output
  integer, intent(inout) ::  edge_group0(nedge)

  !Working
  integer i

  do i=1,nedge
     if (edge_group0(i) .eq. oldGroup) then
        edge_group0(i) = newGroup
     end if
  end do

end subroutine setAll

  

subroutine getKMN(k, nsurf, nedge, ngroup, ratio, ns, surf_edge, edge_group, numD, group_k, group_m, group_n)

  implicit none

  !Fortran-python interface directives
  !f2py intent(in) k, nsurf, nedge, ngroup, ratio, ns, surf_edge, edge_group
  !f2py intent(out) numD, group_k, group_m, group_n
  !f2py depend(nsurf) ns
  !f2py depend(nsurf) surf_edge
  !f2py depend(nedge) edge_group
  !f2py depend(ngroup) group_k
  !f2py depend(ngroup) group_m
  !f2py depend(ngroup) group_n

  !Input
  integer, intent(in) ::  k, nsurf, nedge, ngroup
  double precision, intent(in) ::  ratio
  integer, intent(in) ::  ns(nsurf,2), surf_edge(nsurf,2,2)
  integer, intent(in) ::  edge_group(nedge)

  !Output
  integer, intent(out) ::  numD
  integer, intent(out) ::  group_k(ngroup)
  integer, intent(out) ::  group_m(ngroup)
  integer, intent(out) ::  group_n(ngroup)

  !Working
  integer i,m, ugroup, vgroup

  group_k(:) = k
  group_m(:) = k
  group_n(:) = k
  do i=1,nsurf
     ugroup = edge_group(abs(surf_edge(i,1,1)))
     vgroup = edge_group(abs(surf_edge(i,2,1)))
     group_n(ugroup) = ns(i,1)
     group_n(vgroup) = ns(i,2)
     m = nint(ns(i,1)/ratio)
     if (m .lt. k) then
        m = k
     end if
     group_m(ugroup) = m
     m = nint(ns(i,2)/ratio)
     if (m .lt. k) then
        m = k
     end if
     group_m(vgroup) = m
  end do
  numD = 0
  do i=1,ngroup
     numD = numD + group_m(i) + k
  end do

end subroutine getKMN



subroutine getD(ngroup, numD, group_k, group_m, group_d)

  implicit none

  !Fortran-python interface directives
  !f2py intent(in) ngroup, numD, group_k, group_m
  !f2py intent(out) group_d
  !f2py depend(ngroup) group_k
  !f2py depend(ngroup) group_m
  !f2py depend(numD) group_d

  !Input
  integer, intent(in) ::  ngroup, numD
  integer, intent(in) ::  group_k(ngroup), group_m(ngroup)

  !Output
  double precision, intent(out) ::  group_d(numD)

  !Working
  integer i,i1,i2,k,m
  double precision, allocatable, dimension(:) ::  buffer
  
  i1 = 1
  i2 = 1
  do i=1,ngroup
     k = group_k(i)
     m = group_m(i)
     i2 = i1 + k + m - 1
     allocate(buffer(k+m))
     call knotopen(k,k+m,buffer)
     group_d(i1:i2) = buffer(:)
     deallocate(buffer)
     i1 = i1 + k + m
  end do

end subroutine getD
