
subroutine computeTopology(nsurf, vtol, etol, P, nvert, nedge, surf_vert, surf_edge)

  implicit none

  !Fortran-python interface directives
  !f2py intent(in) nsurf, vtol, etol, P
  !f2py intent(out) nvert, nedge, surf_vert, surf_edge
  !f2py depend(nsurf) P
  !f2py depend(nsurf) surf_vert
  !f2py depend(nsurf) surf_edge

  !Input
  integer, intent(in) ::  nsurf
  double precision, intent(in) ::  vtol, etol
  double precision, intent(in) ::  P(nsurf,3,3,3)

  !Output
  integer, intent(out) ::  nvert, nedge
  integer, intent(out) ::  surf_vert(nsurf,2,2)
  integer, intent(out) ::  surf_edge(nsurf,2,2)

  !Working
  integer surf_ptrs(nsurf,3,3)
  integer i,j
  integer u,v,m,n
  integer du,dv,dm,dn
  integer ivert, iedge
  double precision dP(3), norm
  logical temp

  surf_ptrs(:,:,:) = 0

  ivert = 0
  do i=1,nsurf
     do v=1,3,2
        do u=1,3,2
           if (surf_ptrs(i,u,v) .eq. 0) then
              ivert = ivert + 1
              surf_ptrs(i,u,v) = ivert
              do j=i+1,nsurf
                 do n=1,3,2
                    do m=1,3,2
                       if (surf_ptrs(j,m,n) .eq. 0) then
                          dP(:) = P(i,u,v,:) - P(j,m,n,:)
                          norm = (dP(1)**2+dP(2)**2+dP(3)**2)**0.5
                          if (norm .lt. vtol) then
                             surf_ptrs(j,m,n) = ivert
                          end if
                       end if
                    end do
                 end do
              end do
           end if
        end do
     end do
  end do

  iedge = 0
  do i=1,nsurf
     do v=2,2
        do u=1,3,2
           du = 0
           dv = 1
           if (surf_ptrs(i,u,v) .eq. 0) then
              iedge = iedge + 1
              surf_ptrs(i,u,v) = iedge
              do j=i+1,nsurf
                 do n=2,2
                    do m=1,3,2
                       dm = 0
                       dn = 1
                       call checkEdge(nsurf,iedge,i,j,u,v,m,n,du,dv,dm,dn,etol,P,surf_ptrs)
                    end do
                 end do
                 do n=1,3,2
                    do m=2,2
                       dm = 1
                       dn = 0
                       call checkEdge(nsurf,iedge,i,j,u,v,m,n,du,dv,dm,dn,etol,P,surf_ptrs)
                    end do
                 end do
              end do
           end if
        end do
     end do
     do v=1,3,2
        do u=2,2
           du = 1
           dv = 0
           if (surf_ptrs(i,u,v) .eq. 0) then
              iedge = iedge + 1
              surf_ptrs(i,u,v) = iedge
              do j=i+1,nsurf
                 do n=2,2
                    do m=1,3,2
                       dm = 0
                       dn = 1
                       call checkEdge(nsurf,iedge,i,j,u,v,m,n,du,dv,dm,dn,etol,P,surf_ptrs)
                    end do
                 end do
                 do n=1,3,2
                    do m=2,2
                       dm = 1
                       dn = 0
                       call checkEdge(nsurf,iedge,i,j,u,v,m,n,du,dv,dm,dn,etol,P,surf_ptrs)
                    end do
                 end do
              end do
           end if
        end do
     end do
  end do

  do i=1,nsurf
     surf_vert(i,1,1) = surf_ptrs(i,1,1)
     surf_vert(i,1,2) = surf_ptrs(i,1,3)
     surf_vert(i,2,1) = surf_ptrs(i,3,1)
     surf_vert(i,2,2) = surf_ptrs(i,3,3)
     surf_edge(i,1,1) = surf_ptrs(i,2,1)
     surf_edge(i,1,2) = surf_ptrs(i,2,3)
     surf_edge(i,2,1) = surf_ptrs(i,1,2)
     surf_edge(i,2,2) = surf_ptrs(i,3,2)
  end do

  nvert = ivert
  nedge = iedge

end subroutine computeTopology



subroutine checkEdge(nsurf, iedge, i, j, u, v, m, n, du, dv, dm, dn, etol, P, surf_ptrs)

  implicit none

  !Input
  integer, intent(in) ::  nsurf, iedge, i, j, u, v, m, n, du, dv, dm, dn
  double precision, intent (in) ::  etol, P(nsurf,3,3,3)

  !Output
  integer, intent (inout) ::  surf_ptrs(nsurf,3,3)

  !Working
  double precision dP(3), norm

  if (surf_ptrs(j,m,n) .eq. 0) then
     dP(:) = P(i,u,v,:) - P(j,m,n,:)
     norm = (dP(1)**2+dP(2)**2+dP(3)**2)**0.5
     if ((norm .lt. etol) .and. (surf_ptrs(i,u-du,v-dv) .eq. surf_ptrs(j,m-dm,n-dn)) .and. (surf_ptrs(i,u+du,v+dv) .eq. surf_ptrs(j,m+dm,n+dn))) then
        surf_ptrs(j,m,n) = iedge
     else if ((norm .lt. etol) .and. (surf_ptrs(i,u-du,v-dv) .eq. surf_ptrs(j,m+dm,n+dn)) .and. (surf_ptrs(i,u+du,v+dv) .eq. surf_ptrs(j,m-dm,n-dn))) then
        surf_ptrs(j,m,n) = -iedge
     end if
  end if

end subroutine checkEdge



subroutine countVEptrs(nsurf, nvert, nedge, surf_vert, surf_edge, vert_count, edge_count)

  implicit none

  !Fortran-python interface directives
  !f2py intent(in) nsurf, nvert, nedge, surf_vert, surf_edge
  !f2py intent(out) vert_count, edge_count
  !f2py depend(nsurf) surf_vert
  !f2py depend(nsurf) surf_edge
  !f2py depend(nvert) vert_count
  !f2py depend(nedge) edge_count

  !Input
  integer, intent(in) ::  nsurf, nvert, nedge
  integer, intent(in) ::  surf_vert(nsurf,2,2)
  integer, intent(in) ::  surf_edge(nsurf,2,2)

  !Output
  integer, intent(out) ::  vert_count(nvert), edge_count(nedge)

  !Working
  integer i,u,v,index

  vert_count(:) = 0
  edge_count(:) = 0

  do i=1,nsurf
     do v=1,2
        do u=1,2
           vert_count(abs(surf_vert(i,u,v))) = vert_count(abs(surf_vert(i,u,v))) + 1
        end do
     end do
     do v=1,2
        do u=1,2       
           edge_count(abs(surf_edge(i,u,v))) = edge_count(abs(surf_edge(i,u,v))) + 1  
        end do
     end do
  end do

end subroutine countVEptrs
